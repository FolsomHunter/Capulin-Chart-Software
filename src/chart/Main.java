/******************************************************************************
* Title: Chart - Main Source File
* Author: Mike Schoonover
* Date: 03/12/08
*
* Purpose:
*
* This program provides display, charting, motion tracking, data saving,
* event marking, and firing external hardware event markers (paint markers,
* sirens, signal lights).
*
* Open Source Policy:
*
* This source code is Public Domain and free to any interested party.  Any
* person, company, or organization may do with it as they please.
*
*/

//-----------------------------------------------------------------------------

package chart;

import java.awt.*;
import javax.swing.*;
import java.io.*;
import java.text.DecimalFormat;
import java.awt.event.WindowListener;
import java.awt.event.WindowEvent;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentListener;
import java.awt.event.ComponentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.event.DocumentEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;
import javax.swing.JOptionPane;
import javax.swing.JDialog;

import chart.mksystems.globals.Link;
import chart.mksystems.globals.Globals;
import chart.mksystems.inifile.IniFile;
import chart.mksystems.menu.MainMenu;
import chart.mksystems.stripchart.ChartGroup;
import chart.mksystems.hardware.Hardware;
import chart.mksystems.hardware.Channel;
import chart.mksystems.hardware.AScan;

//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// class MainThread
//
// This thread drives the data collection from the hardware.
//
//

class MainThread implements Runnable {

int i = 0;

public Hardware hardware;
Globals globals;
UTCalibrator calWindow;

//-----------------------------------------------------------------------------
// MainThread::MainThread (constructor)
//

public MainThread(UTCalibrator pCalWindow, Globals pGlobals)
{

calWindow = pCalWindow; globals = pGlobals;

}//end of MainThread::MainThread (constructor)
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainThread::run
//

@Override
public void run() {

try{
    while (true){

        //if connection has not been made to the remotes, do so
        if (!hardware.connected) hardware.connect();

        //the hardware.connect function will not return until all boards
        //are setup, so the setup can access sockets without worry of collision
        //with the hardware.collectData function which also accesses those
        //same sockets - after the connect call returns, then collectData
        //will repeatedly be called from this timer and other functions should
        //not read from the sockets to avoid collision with collectData

        //trigger data collection from remote devices
        //this does not display the data - that is handled by a timer

        hardware.collectData();

        //if the calibration window is active, request aScan packets
        //thus, if the user clicks off the window, the AScan will freeze
        if (calWindow.isActive()){

            if (calWindow.channels[calWindow.currentChannelIndex] != null){
                hardware.requestAScan(
                calWindow.channels[calWindow.currentChannelIndex].channelIndex);
                }

            }// if (calWindow.isActive())

        hardware.sendDataChangesToRemotes();

        Thread.sleep(10);

        }//while

    }//try

catch (InterruptedException e) {
    }

}//end of MainThread::run
//-----------------------------------------------------------------------------

}//end of class MainThread
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// class MainWindow
//
// Creates a main window JFrame.  Creates all other objects needed by the
// program.
//
// Listens for events generated by the main window.  Calls clean up functions
// on program exit.
//

class MainWindow implements WindowListener, ActionListener, ChangeListener,
                                ComponentListener, DocumentListener, Link {

Globals globals;
String language;
Xfer xfer;

FileSaver fileSaver = null;

String currentJobName;
String currentJobPrimaryPath, currentJobBackupPath, reportsPath;
String primaryDataPath;
String backupDataPath;

JFrame mainFrame;
JDialog measureDialog;
GridBagLayout gridBag;
ControlPanel controlPanel;

MainMenu mainMenu;
MainThread mainThread;

Timer mainTimer;

int numberOfChartGroups;
ChartGroup[] chartGroups;

int numberOfChannels;
Channel[] calChannels;

Hardware hardware;

Log logWindow;
JobInfo jobInfo;
PieceInfo pieceIDInfo;
Debugger debugger;
UTCalibrator calWindow;
Monitor monitorWindow;
boolean monitorMode = false;

FlagReportPrinter printFlagReportDialog = null;
int closePrintFlagReportDialogTimer = 0;

AScan aScan;

int initialWidth, initialHeight;

DecimalFormat[] decimalFormats;

int lastPieceInspected = -1;
boolean isLastPieceInspectedACal = false;

//-----------------------------------------------------------------------------
// MainWindow::MainWindow (constructor)
//

public MainWindow()
{

//turn off default bold for Metal look and feel
UIManager.put("swing.boldMetal", Boolean.FALSE);

//force "look and feel" to Java style
try {
    UIManager.setLookAndFeel(
        UIManager.getCrossPlatformLookAndFeelClassName());
    }
catch (Exception e) {}

//create various decimal formats
decimalFormats = new DecimalFormat[1];
decimalFormats[0] = new  DecimalFormat("0000000");

//convert all config files from UTF-16LE to UTF-8 format
//(this does not convert files already in use in the job folders)
UTF16LEToUTF8Converter converter = new UTF16LEToUTF8Converter();
converter.init();

globals = new Globals(this, this);

xfer = new Xfer();

//create the program's main window
mainFrame = new JFrame("Java Chart");
//do not auto exit on close - shut down handled by the timer function
mainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
mainFrame.addComponentListener(this);
mainFrame.addWindowListener(this);

//change the layout manager
BoxLayout boxLayout =
                    new BoxLayout(mainFrame.getContentPane(), BoxLayout.Y_AXIS);
//mainFrame.setLayout(new BoxLayout(mainFrame, BoxLayout.Y_AXIS));
mainFrame.getContentPane().setLayout(boxLayout);

loadLanguage(globals.language); //set text on main form

//create a main menu, passing globals as the object to be installed as
//the action and item listener for the menu
mainFrame.setJMenuBar(mainMenu = new MainMenu(globals));

//loads configurations settings for the program
loadGeneralConfiguration();

//loads settings such as the data paths and other values which rarely change
loadMainStaticSettings();

//loads settings such as current job name, etc.
loadMainSettings();

//read the configuration file and create/setup the charting/control elements
//loads the job file
configure();

mainFrame.setLocation(globals.mainWindowLocationX, globals.mainWindowLocationY);

mainFrame.pack();
mainFrame.setVisible(true);

//store the height and width of the main window after it has been set up so
//it can be restored to this size if an attempt is made to resize it
initialWidth = mainFrame.getWidth();
initialHeight = mainFrame.getHeight();

//reset the charts
resetChartGroups();

//tell cal window to create an image
calWindow.scope1.createImageBuffer();
calWindow.scope1.clearPlot();

//create and start a thread to collect data from the hardware
mainThread = new MainThread(calWindow, globals);
Thread thread = new Thread(mainThread, "Main Thread");
mainThread.hardware = hardware;
thread.start();

//Create and start a timer which will handle updating the displays.
mainTimer = new Timer(10, this);
mainTimer.setActionCommand("Timer");
mainTimer.start();

//allow all objects to update values dependent on display sizes
handleSizeChanges();

//force garbage collection before beginning any time sensitive tasks
System.gc();

//check to see if license has expired
LicenseValidator  lv = new LicenseValidator(mainFrame, "Graphics.ini");
lv.validateLicense();

}//end of MainWindow::MainWindow (constructor)
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::loadMainStaticSettings
//
// Loads settings such as the data file paths, etc.
// These values do not change from job to job and are only updated by the
// program during setup.
//

private void loadMainStaticSettings()
{

IniFile configFile = null;

//if the ini file cannot be opened and loaded, exit without action
try {configFile = new IniFile("Main Static Settings.ini",
                                                    Globals.mainFileFormat);}
    catch(IOException e){return;}

//set the data folders to empty if values cannot be read from the ini file
//all functions which write data should abort if the folder names are empty

primaryDataPath = formatPath(configFile.readString(
                               "Main Configuration", "Primary Data Path", ""));

backupDataPath = formatPath(configFile.readString(
                                "Main Configuration", "Backup Data Path", ""));

reportsPath = formatPath(configFile.readString(
                                    "Main Configuration", "Reports Path", ""));

}//end of MainWindow::loadMainStaticSettings
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::formatPath
//
// Append a fwd/backslash if pPath does not already end with one.
// Use File.separator to apply the correct character for the operating system.
//

private String formatPath (String pPath){

    if (!pPath.equals("") && !pPath.endsWith(File.separator))
        pPath += File.separator;

    return(pPath);

}//end of MainWindow::formatPath
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::saveMainStaticSettings
//
// Saves settings such as the data file paths, etc.
// These values do not change from job to job and are only updated by the
// program during setup.
//

private void saveMainStaticSettings()
{

IniFile configFile = null;

//if the ini file cannot be opened and loaded, exit without action
try {configFile = new IniFile("Main Static Settings.ini",
                                                       Globals.mainFileFormat);}
    catch(IOException e){
        System.err.println("Error opening: " + "Main Static Settings.ini");
        return;
        }

configFile.writeString("Main Configuration", "Primary Data Path",
                                                               primaryDataPath);

configFile.writeString("Main Configuration", "Backup Data Path",
                                                                backupDataPath);

//force save
configFile.save();

}//end of MainWindow::saveMainStaticSettings
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::loadGeneralConfiguration
//
// Loads general configuration settings.
//

private void loadGeneralConfiguration()
{

IniFile configFile = null;

//if the ini file cannot be opened and loaded, exit without action
try {configFile = new IniFile(
                       "Configuration - General.ini", Globals.mainFileFormat);}
    catch(IOException e){return;}

globals.primaryFolderName = configFile.readString(
                        "Main Configuration", "Primary Data Folder Name",
                                            "IR Scan Data Files -  Primary");

globals.backupFolderName = configFile.readString(
                            "Main Configuration", "Backup Data Folder Name",
                        "Backup Data Folder Name=IR Scan Data Files - Backup");

//replace any forward/back slashes with the filename separator appropriate
//for the system the program is running on

String sep = File.separator;
globals.primaryFolderName = globals.primaryFolderName.replace("/", sep);
globals.primaryFolderName = globals.primaryFolderName.replace("\\", sep);
globals.backupFolderName = globals.backupFolderName.replace("/", sep);
globals.backupFolderName = globals.backupFolderName.replace("\\", sep);

//if there is a separator at the end, remove it for consistency with later code
String t = globals.primaryFolderName;
if (t.endsWith(sep))
    globals.primaryFolderName = t.substring(0, t.length()-1);

t = globals.backupFolderName;
if (t.endsWith(sep))
    globals.backupFolderName = t.substring(0, t.length()-1);


globals.printResolutionX = configFile.readInt(
                                 "Printer", "Printer Resolution X in DPI", 300);

globals.printResolutionY = configFile.readInt(
                                 "Printer", "Printer Resolution Y in DPI", 300);

globals.printQuality  = configFile.readString(
                    "Printer", "Print Quality (Draft, Normal, High)", "Normal");

}//end of MainWindow::loadGeneralConfiguration
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::loadMainSettings
//
// Loads settings such as the current work order.
// These values often changed as part of normal operation.
//

private void loadMainSettings()
{

IniFile configFile = null;

//if the ini file cannot be opened and loaded, exit without action
try {configFile = new IniFile("Main Settings.ini", Globals.mainFileFormat);}
    catch(IOException e){return;}

currentJobName = configFile.readString(
                         "Main Configuration", "Current Work Order", "");

JobValidator jobValidator = new JobValidator(primaryDataPath, backupDataPath,
                                                  currentJobName, false, xfer);

//if flag returns true, one or both of the root data paths is missing - set
//both and the job name to empty so they won't be accessed
if (xfer.rBoolean2){
    primaryDataPath = ""; backupDataPath = "";
    currentJobName = "";
    }

//if flag returns true, the root folders exist but the job name cannot be found
//in either - assume that it no longer exists and set the name empty
if (xfer.rBoolean3) currentJobName = "";

currentJobPrimaryPath = ""; currentJobBackupPath = "";

//if the root paths and the job name are valid, create the full paths
if(!currentJobName.equals("")){
    if(!primaryDataPath.equals("")) currentJobPrimaryPath =
                            primaryDataPath + currentJobName + File.separator;
    if(!backupDataPath.equals("")) currentJobBackupPath =
                             backupDataPath + currentJobName + File.separator;
    }

globals.mainWindowLocationX = configFile.readInt(
                        "Main Configuration", "Main Window Location X", 0);

globals.mainWindowLocationY = configFile.readInt(
                        "Main Configuration", "Main Window Location Y", 0);

globals.utCalWindowLocationX = configFile.readInt(
                   "Main Configuration", "UT Calibrator Window Location X", 0);

globals.utCalWindowLocationY = configFile.readInt(
                   "Main Configuration", "UT Calibrator Window Location Y", 0);

}//end of MainWindow::loadMainSettings
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::saveMainSettings
//
// Saves settings such as the current work order.
// These values often changed as part of normal operation.
//

private void saveMainSettings()
{

IniFile configFile = null;

//if the ini file cannot be opened and loaded, exit without action
try {configFile = new IniFile("Main Settings.ini", Globals.mainFileFormat);}
catch(IOException e){
    System.err.println("Error opening: " + "Main Settings.ini");
    return;
    }

configFile.writeString(
                 "Main Configuration", "Current Work Order", currentJobName);

//force save
configFile.save();

}//end of MainWindow::saveMainSettings
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::configure
//
// Loads configuration settings from the configuration.ini file.  These set
// the number of charts, traces, thresholds, channels, positions, colors, etc.
//
// After obtaining the config data necessary for the main window itself, the
// various child objects are created according to the config data specs.  The
// config file is passed to each child object to allow them to load their own
// config data.
//

private void configure()
{

String configFilename = currentJobPrimaryPath + "01 - " + currentJobName
                                                        + " Configuration.ini";

if(IniFile.detectUTF16LEFormat(configFilename))
    globals.jobFileFormat = "UTF-16LE";
else
    globals.jobFileFormat = "UTF-8";

IniFile configFile = null;

//if the ini file cannot be opened and loaded, exit without action
try {
    configFile = new IniFile(configFilename, globals.jobFileFormat);
    }
catch(IOException e){return;}

//create an object to hold job info
jobInfo = new JobInfo(mainFrame, currentJobPrimaryPath,
             currentJobBackupPath, currentJobName, this, globals.jobFileFormat);

//create an object to hold info about each piece
pieceIDInfo = new PieceInfo(mainFrame, currentJobPrimaryPath,
      currentJobBackupPath, currentJobName, this, false, globals.jobFileFormat);
pieceIDInfo.init();

//create a window for displaying messages
logWindow = new Log(mainFrame); logWindow.setVisible(true);

//create a window for monitoring status and inputs
monitorWindow = new Monitor(mainFrame, configFile, this);
monitorWindow.init();

//create the hardware interface first so the traces can link to it
hardware = new Hardware(configFile, globals, logWindow.textArea);

//create a debugger window with a link to the hardware object
debugger = new Debugger(mainFrame, hardware);

//create an array to hold references to each channel for the strip chart
//which invoked the opening of the cal window
//the array is made big enough to hold all possible channels even though they
//may be split amongst charts and would not require a full array for each
//calibration window which only handles the number of channels assigned to the
//chart which invoked the window - it is possible that ALL channels could be
//assigned to one chart, so it is easier to make the array overly large

numberOfChannels = hardware.getNumberOfChannels();
calChannels = new Channel[numberOfChannels];

//create after hardware object created
calWindow = new UTCalibrator(mainFrame, hardware, globals);
calWindow.init();

globals.configure(configFile);

//don't use these - let contents set size of window
//mainFrame.setMinimumSize(new Dimension(1100,1000));
//mainFrame.setPreferredSize(new Dimension(1100,1000));
//mainFrame.setMaximumSize(new Dimension(1100,1000));

String title = configFile.readString(
                    "Main Configuration", "Main Window Title", "Java Chart");

mainFrame.setTitle(title);

globals.simulationMode = configFile.readBoolean(
                            "Main Configuration", "Simulation Mode", false);

globals.simulateMechanical = configFile.readBoolean(
                                "Hardware", "Simulate Mechanical", false);

globals.copyToAllMode = configFile.readInt(
                                "Main Configuration", "Copy to All Mode", 0);

//if true, the traces will be driven by software timer rather than by
//encoder inputs - used for weldline crabs and systems without encoders
globals.timerDrivenTracking = configFile.readBoolean(
                                "Hardware", "Timer Driven Tracking", false);

numberOfChartGroups =
          configFile.readInt("Main Configuration", "Number of Chart Groups", 1);

//create an array of chart groups per the config file setting
if (numberOfChartGroups > 0){

    //protect against too many groups
    if (numberOfChartGroups > 10) numberOfChartGroups = 10;

    chartGroups = new ChartGroup[numberOfChartGroups];

    for (int i = 0; i < numberOfChartGroups; i++){
        chartGroups[i] = new ChartGroup(
                    globals, configFile, i, hardware, this, false, hardware);
        mainFrame.add(chartGroups[i]);
        }

    }//if (numberOfChartGroups > 0)

//give hardware a connection to the charts
hardware.chartGroups = chartGroups;

//create a panel to hold user controls and status displays
mainFrame.add(controlPanel =
    new ControlPanel(configFile, currentJobPrimaryPath,
    currentJobBackupPath, hardware, mainFrame, this,
    currentJobName, globals, hardware));

//load user adjustable settings
loadCalFile();

//force menu settings to match any variables loaded from disk
mainMenu.refreshMenuSettings();

//force screen control values to match any variables loaded from disk
controlPanel.refreshControls();

}//end of MainWindow::configure
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::loadCalFile
//
// This loads the file used for storing calibration information pertinent to a
// job, such as gains, offsets, thresholds, etc.
//
// Each object is passed a pointer to the file so that they may load their
// own data.
//

private void loadCalFile()
{

IniFile calFile = null;

//if the ini file cannot be opened and loaded, exit without action
try {
    calFile = new IniFile(currentJobPrimaryPath + "00 - "
             + currentJobName + " Calibration File.ini", globals.jobFileFormat);
    }
    catch(IOException e){return;}

//if true, traces will restart at left edge of chart for each new piece
//if false, new piece will be added to end of traces while chart scrolls
globals.restartNewPieceAtLeftEdge = calFile.readBoolean("General",
                          "Restart Each New Piece at Left Edge of Chart", true);

//settings which control peak hold display on the A Scan
globals.showRedPeakLineInGateCenter = calFile.readBoolean("General",
                                    "Show Red Peak Line at Gate Center", false);
globals.showRedPeakLineAtPeakLocation = calFile.readBoolean("General",
                                  "Show Red Peak Line at Peak Location", false);
globals.showPseudoPeakAtPeakLocation = calFile.readBoolean("General",
                                  "Show Peak Symbol at Peak Location", true);

globals.scanSpeed =
                calFile.readInt("General", "Scanning and Inspecting Speed", 10);

if (globals.scanSpeed < 0 || globals.scanSpeed > 10) globals.scanSpeed = 10;

globals.graphPrintLayout =
 calFile.readString("General", "Graph Print Layout", "8-1/2 x 11 : Fit Height");

//make sure print layout is one of the valid values
if (!globals.graphPrintLayout.equalsIgnoreCase("8-1/2 x 11 : Fit Height")
    && !globals.graphPrintLayout.equalsIgnoreCase("8-1/2 x 11 : Fit Width")
    && !globals.graphPrintLayout.equalsIgnoreCase("8-1/2 x 14 : Fit Height")
    && !globals.graphPrintLayout.equalsIgnoreCase("8-1/2 x 14 : Fit Width")
    && !globals.graphPrintLayout.equalsIgnoreCase("A4 : Fit Height")
    && !globals.graphPrintLayout.equalsIgnoreCase("A4 : Fit Width"))
    globals.graphPrintLayout = "8-1/2 x 11 : Fit Height";

globals.userPrintMagnify = calFile.readString(
                               "General", "Graph Print Magnify", "Magnify 1.0");

//load info for all charts
for (int i=0; i < numberOfChartGroups; i++) chartGroups[i].loadCalFile(calFile);

hardware.loadCalFile(calFile);

}//end of MainWindow::loadCalFile
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::saveCalFile

private void saveCalFile()
{

//create a FileSaver thread object to save the data - this allows status
//messages to be displayed and updated during the save
fileSaver = new FileSaver(this);
fileSaver.start();

}//end of MainWindow::saveCalFile
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::saveCalFileHelper
//
// This saves the file used for storing calibration information pertinent to a
// job, such as gains, offsets, thresholds, etc.
//
// Each object is passed a pointer to the file so that they may save their
// own data.
//

protected void saveCalFileHelper(String pJobPath)
{

//if the job path has not been set, don't save anything or it will be saved in
//the program root folder -- this occurs when the current job path specified in
//the Main Settings.ini

if (pJobPath.equals("")) return;

IniFile calFile = null;

//if the ini file cannot be opened and loaded, exit without action
try {
    calFile = new IniFile(pJobPath + "00 - "
             + currentJobName + " Calibration File.ini", globals.jobFileFormat);
    }
    catch(IOException e){return;}

//if true, traces will restart at left edge of chart for each new piece
//if false, new piece will be added to end of traces while chart scrolls
calFile.writeBoolean("General", "Restart Each New Piece at Left Edge of Chart",
                                             globals.restartNewPieceAtLeftEdge);

//settings which control peak hold display on the A Scan
calFile.writeBoolean("General", "Show Red Peak Line at Gate Center",
                                        globals.showRedPeakLineInGateCenter);
calFile.writeBoolean("General", "Show Red Peak Line at Peak Location",
                                        globals.showRedPeakLineAtPeakLocation);
calFile.writeBoolean("General", "Show Peak Symbol at Peak Location",
                                        globals.showPseudoPeakAtPeakLocation);

calFile.writeInt("General", "Scanning and Inspecting Speed", globals.scanSpeed);

calFile.writeString("General", "Graph Print Layout", globals.graphPrintLayout);

calFile.writeString("General", "Graph Print Magnify", globals.userPrintMagnify);

//save info for all charts
for (int i=0; i < numberOfChartGroups; i++) chartGroups[i].saveCalFile(calFile);

hardware.saveCalFile(calFile);

//force save
calFile.save();

}//end of MainWindow::saveCalFileHelper
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::saveEverything
//
// Saves all settings.  Some of the save functions may not actually save the
// data if it has not been changed since the last save.
//

private void saveEverything()
{

//save cal file last - the program won't exit while cal files are being saved
//so that means all files will be finished saving

//save miscellaneous settings
saveMainSettings();
//save next piece and cal piece numbers
controlPanel.saveSettings();
//save all user calibration settings
saveCalFile();

}//end of MainWindow::saveEverything
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::resetChartGroups
//
// Erases the chart groups and clears all data.
//

private void resetChartGroups()
{

for (int i = 0; i < numberOfChartGroups; i++) chartGroups[i].resetChartGroup();

}//end of MainWindow::resetChartGroups
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::markSegmentStart
//
// Prepares to record a new data segment.
//
// Resets the counter which is used to determine if a new segment has begun
// and records the start position.
//
// This function should be called whenever a new segment is to start - each
// segment could represent a piece being monitored, a time period, etc.
//

public void markSegmentStart()
{

for (int i = 0; i < numberOfChartGroups; i++)
    chartGroups[i].markSegmentStart();

}//end of MainWindow::markSegmentStart
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::markSegmentEnd
//
// Marks the buffer location of the end of the current segment.
//
// This function should be called whenever a new segment is to end - each
// segment could represent a piece being monitored, a time period, etc.
//
// This function should be called before saving the data so the end points
// of the data to be saved are known.
//

public void markSegmentEnd()
{

for (int i = 0; i < numberOfChartGroups; i++)
    chartGroups[i].markSegmentEnd();

}//end of MainWindow::markSegmentEnd
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::segmentStarted
//
// Checks to see if a segment has been started and thus may have data which
// needs to be saved.
//

boolean segmentStarted()
{

for (int i = 0; i < numberOfChartGroups; i++)
    if (chartGroups[i].segmentStarted()) return(true);

return(false);

}//end of MainWindow::segmentStarted
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::saveSegment
//
// Saves the data for a segment to the primary and backup job folders.
//
// This function should be called whenever a new segment is completed - each
// segment could represent a piece being monitored, a time period, etc.
//
// This function should be called after the segment end has been marked and
// before the next segment start has been marked so that the end points
// of the data to be saved are known.
//

private void saveSegment()
{

String segmentFilename;

isLastPieceInspectedACal = controlPanel.calMode;

//inspected pieces are saved with the prefix 20 while calibration pieces are
//saved with the prefix 30 - this forces them to be grouped together and
//controls the order in which the types are listed when the folder is viewed
//in alphabetical order in an explorer window

if (!controlPanel.calMode){
    segmentFilename = "20 - " +
               decimalFormats[0].format(controlPanel.nextPieceNumber) + ".dat";
    //save number before it changes to the next -- used for reports and such
    lastPieceInspected = controlPanel.nextPieceNumber;
}
else{
    segmentFilename =  "30 - " +
            decimalFormats[0].format(controlPanel.nextCalPieceNumber) + ".cal";
    //save number before it changes to the next -- used for reports and such
    lastPieceInspected = controlPanel.nextCalPieceNumber;
}

saveSegmentHelper(currentJobPrimaryPath + segmentFilename);
saveSegmentHelper(currentJobBackupPath + segmentFilename);


//save the info file for each segment
//this is info which can be modified later such as heat, lot, id number, etc.

if (!controlPanel.calMode)
    segmentFilename = "20 - " +
               decimalFormats[0].format(controlPanel.nextPieceNumber) + ".info";
else
    segmentFilename =  "30 - " +
        decimalFormats[0].format(controlPanel.nextCalPieceNumber) + ".cal info";

saveSegmentInfoHelper(currentJobPrimaryPath + segmentFilename);
saveSegmentInfoHelper(currentJobBackupPath + segmentFilename);

}//end of MainWindow::saveSegment
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::saveSegmentHelper
//
// Saves the data for a segment to the specified file.  See the saveSegment
// function for more info.
//

private void saveSegmentHelper(String pFilename)
{

//create a buffered writer stream

FileOutputStream fileOutputStream = null;
OutputStreamWriter outputStreamWriter = null;
BufferedWriter out = null;

try{

    fileOutputStream = new FileOutputStream(pFilename);
    outputStreamWriter = new OutputStreamWriter(fileOutputStream,
                                                         globals.jobFileFormat);
    out = new BufferedWriter(outputStreamWriter);

    //write the header information - this portion can be read by the iniFile
    //class which will only read up to the "[Header End]" tag - this allows
    //simple parsing of the header information while ignoring the data stream
    //which  follows the header

    out.write("[Header Start]"); out.newLine();
    out.newLine();
    out.write("Segment Data Version=" + Globals.SEGMENT_DATA_VERSION);
    out.newLine();
    out.write("Measured Length=" + hardware.hdwVs.measuredLength);
    out.newLine();
    out.write("Inspection Direction="
                                    + hardware.inspectionDirectionDescription);
    out.newLine();
    out.write("[Header End]"); out.newLine(); out.newLine();

    for (int i = 0; i < numberOfChartGroups; i++)
        chartGroups[i].saveSegment(out);
    }
catch(IOException e){}
finally{
    try{if (out != null) out.close();}
    catch(IOException e){}
    try{if (outputStreamWriter != null) outputStreamWriter.close();}
    catch(IOException e){}
    try{if (fileOutputStream != null) fileOutputStream.close();}
    catch(IOException e){}
    }

}//end of MainWindow::saveSegmentHelper
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::saveSegmentInfoHelper
//
// Saves the non-inspection data for a segment to the specified file.  See the
// saveSegment function for more info.
//
// Each piece saved has a *.dat file containing the graph data and a *.info
// file containing info such as joint number, id number, heat number, lot
// number, etc.
//
// In general, data which should never be changed in the future is all saved in
// the *.dat file -- graph data, calibration data, etc.
//
// Data which might need to be modified later is stored in the *.info file.
//

private void saveSegmentInfoHelper(String pFilename)
{

//create a buffered writer stream

FileOutputStream fileOutputStream = null;
OutputStreamWriter outputStreamWriter = null;
BufferedWriter out = null;

try{

    fileOutputStream = new FileOutputStream(pFilename);
    outputStreamWriter = new OutputStreamWriter(fileOutputStream,
                                                         globals.jobFileFormat);
    out = new BufferedWriter(outputStreamWriter);

    //write a warning note at the top of the file

    out.newLine();
    out.write(";Do not erase blank line above -"
               + " has hidden code needed by UTF-16 files.");
    out.newLine(); out.newLine();

    //write the header information - this portion can be read by the iniFile
    //class which will only read up to the "[Header End]" tag - this allows
    //simple parsing of the header information while ignoring the data stream
    //which  follows the header

    out.write("[MetaData]"); out.newLine();
    out.newLine();
    out.write("Segment Data Version=" + Globals.SEGMENT_DATA_VERSION);
    out.newLine();
    out.newLine();
    out.write("[MetaData End]"); out.newLine(); out.newLine();

    out.newLine();

    //allow the pieceInfo object to save its data to the file
    pieceIDInfo.saveDataToStream(out);

    }
catch(IOException e){}
finally{
    try{if (out != null) out.close();}
    catch(IOException e){}
    try{if (outputStreamWriter != null) outputStreamWriter.close();}
    catch(IOException e){}
    try{if (fileOutputStream != null) fileOutputStream.close();}
    catch(IOException e){}
    }

}//end of MainWindow::saveSegmentInfoHelper
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::handleSizeChanges
//
// Updates any values related to the size of display objects.  Called after
// the display has been set and any time a size may have changed.
//

public final void handleSizeChanges()
{

for (int i = 0; i < numberOfChartGroups; i++)
                                            chartGroups[i].handleSizeChanges();

}//end of MainWindow::handleSizeChanges
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::actionPerformed
//
// Responds to button events.
//

@Override
public void actionPerformed(ActionEvent e)
{

//this part handles saving all data
if ("Save".equals(e.getActionCommand())) {
    if(isConfigGoodA()) saveEverything();
    return;
    }

//this part handles creating a new job
if ("New Job".equals(e.getActionCommand())) {
    if(isConfigGoodB()) createNewJob();
    return;
    }

//this part handles switching to a different job
if ("Change Job".equals(e.getActionCommand())) {
    if(isConfigGoodB()) changeJob();
    return;
    }

//this part handles saving current settings to a preset
if ("Copy Preset From Job".equals(e.getActionCommand())) {
    if(isConfigGoodA()) copyPreset();
    return;
    }

//this part handles saving current settings to a preset
if ("Save Preset".equals(e.getActionCommand())) {
    new SavePreset(mainFrame, primaryDataPath, backupDataPath,
                                                          xfer, currentJobName);
    return;
    }

//this part handles switching to a different preset
if ("Change Preset".equals(e.getActionCommand())) {
    if(isConfigGoodA()) changePreset();
    return;
    }

//this part handles renaming a preset
if ("Rename Preset".equals(e.getActionCommand())) {
    new RenamePreset(mainFrame, primaryDataPath, backupDataPath, xfer);
    return;
    }

//this part handles deleting a preset
if ("Delete Preset".equals(e.getActionCommand())) {
    new DeletePreset(mainFrame, primaryDataPath, backupDataPath, xfer);
    return;
    }

//this part displays the log window
if ("Log".equals(e.getActionCommand())) {
    logWindow.setVisible(true);
    return;
    }

//this part writes various status messages to the log window
if ("Status".equals(e.getActionCommand())) {
    logWindow.setVisible(true);
    logStatus();
    return;
    }

//this part opens a viewer window for viewing saved segments
if ("Open Viewer".equals(e.getActionCommand())) {

    if(isConfigGoodA()) {
        Viewer viewer;
        viewer = new Viewer(globals, jobInfo, currentJobPrimaryPath,
                                        currentJobBackupPath, currentJobName);
        viewer.init();
        }
    return;
    }

//this part opens a window to print a flag report
if ("Print Flag Report for Last Piece Inspected".equals(e.getActionCommand())) {
    //pass the number and type of the last joint inspected so it can be
    //printed without the user having to
    printFlagReport(lastPieceInspected, isLastPieceInspectedACal);
}

//this part opens a window to print a flag report
if ("Print Flag Report for User Selection".equals(e.getActionCommand())) {
    printFlagReport(-1, false);
}


//this part handles starting the status monitor
if ("Monitor".equals(e.getActionCommand())) {
    monitorWindow.setVisible(true);
    hardware.startMonitor();
    return;
    }

//this part handles opening the debugger window
if ("Debugger".equals(e.getActionCommand())) {
    debugger.setVisible(true);
    return;
    }

//this part handles opening the Job Info window
if ("Job Info".equals(e.getActionCommand())) {
    if(isConfigGoodA()) jobInfo.setVisible(true);
    return;
    }

//this part handles opening the piece Identifier Info window
if ("Show ID Info Window".equals(e.getActionCommand())) {
    if(isConfigGoodA()) pieceIDInfo.setVisible(true);
    return;
    }

//this part handles zeroing the encoder counts
if ("Zero Encoder Counts".equals(e.getActionCommand())) {
    hardware.zeroEncoderCounts();
    return;
    }

//this part handles pulsing Output 1
if ("Pulse Output 1".equals(e.getActionCommand())) {
    hardware.pulseOutput1();
    return;
    }

//this part handles repairing a job
if ("Repair Job".equals(e.getActionCommand())) {

    if(!isConfigGoodA()) return;

    //create with pRobust set true so paths will be recreated if necessary
    JobValidator jobValidator = new JobValidator(currentJobPrimaryPath,
                             currentJobBackupPath, currentJobName, true, xfer);

    displayInfoMessage("The repair is complete.  Click OK to reload the job.");

    //reload the job to refresh any changes from the repair
    //exit the program, passing true to instantiate a new program which will
    //reload the job on startup - it is required to create a new
    //program and kill the old one so that all of the configuration data for
    //the job will be loaded properly

    exitProgram(false, true);

    return;
    }

//this part handles updating the Rabbit code
if ("Update UT Rabbit Code".equals(e.getActionCommand())) {
    hardware.updateRabbitCode(Hardware.UT_RABBITS);
    return;
    }

//this part handles updating the Rabbit code
if ("Update Control Rabbit Code".equals(e.getActionCommand())) {
    hardware.updateRabbitCode(Hardware.CONTROL_RABBITS);
    return;
    }

//this part handles setting up the system
if ("Setup System".equals(e.getActionCommand())) {setupSystem(); return;}

//this part handles renewing the license
if ("Renew License".equals(e.getActionCommand())) {
    //asks user to enter a new license renewal code
    //(the window doesn't refer to it being a license renewal code but rather
    // asks for a response code so the user isn't alerted to the fact that
    // an expiration date is in use)
    LicenseValidator  lv = new LicenseValidator(mainFrame, "Graphics.ini");
    //NOTE: the old license file will not be altered unless the user enters
    // a new valid code.  This way a working system won't be broken by an
    // attempt to update the license before the expiration.  The new license
    // will not take effect until the next resart.
    lv.requestLicenseRenewal(false);
    return;
    }

//this part handles requests by ChartGroup objects to open the cal window
//the chart index number is appended to the command string, so use startsWith
if (e.getActionCommand().startsWith("Open Calibration Window")) {
    displayCalWindow(e.getActionCommand());
    return;
    }

//prepare for the next piece to be inspected
if ("Prepare for Next Piece".equals(e.getActionCommand())) {
    prepareForNextPiece();
    return;
    }

//this part processes a finished piece by saving data, adjusting next piece
//number, etc.
if ("Process finished Piece".equals(e.getActionCommand())) {
    processFinishedPiece();
    return;
    }// if ("Process finished Piece".equals(e.getActionCommand()))

//this part handles displaying the "About" window
if ("About".equals(e.getActionCommand())) {
    About about = new About(mainFrame);
    return;
    }

if ("Display Configuration Info".equals(e.getActionCommand())){
    globals.displayConfigInfo(logWindow.textArea);
    logWindow.setVisible(true);
    }

//handle timer calls
if ("Timer".equals(e.getActionCommand())) processMainTimerEvent();

}//end of MainWindow::actionPerformed
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::printFlagReport
//
// Prints a flag report.  If pPieceToPrint is not -1 then that piece will
// be printed with pIsCalPiece specifying inspection or cal piece.  If it is
// -1, then a dialog will be displayed to allow the user to specify the
// piece or pieces to print.
//
//

public void printFlagReport(int pPieceToPrint, boolean pIsCalPiece)
{

    FlagReportPrinter lPrintFlagReportDialog = new FlagReportPrinter(
       mainFrame, globals, jobInfo,
       currentJobPrimaryPath, currentJobBackupPath, reportsPath, currentJobName,
       (int)mainFrame.getLocation().getX() + 80,
       (int)mainFrame.getLocation().getY() + 30,
       globals.pieceDescriptionPlural, globals.pieceDescriptionPluralLC,
       hardware, pPieceToPrint, pIsCalPiece);

    lPrintFlagReportDialog.init();


    //if the piece to be printed was specified, the dialog displays a message
    //but requires no user input -- in that case, set up so that timer can
    //automatically close the dialog after a pause

    if(pPieceToPrint != -1){
        printFlagReportDialog = lPrintFlagReportDialog;
        closePrintFlagReportDialogTimer = 100;
    }

}//end of MainWindow::printFlagReport
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::processFinishedPiece
//
// Process a completed piece by saving it, analyzing it, etc.
//

public void processFinishedPiece()
{

//if an inspection was started, save the data and increment to the next
//piece number - if an inspection was not started, ignore so that the
//piece number is not incremented needlessly when the user clicks "Stop"
//or "Next Run" without having inspected a piece

if (segmentStarted()){

    markSegmentEnd();  //mark the buffer location of the end of the segment

    //if data paths are good, save the data for the segment
    if(isConfigGoodA()) saveSegment();

    //increment the next piece or next cal piece number
    controlPanel.incrementPieceNumber();

    //display the min wall from the just finished piece
    updatePrevMinWallDisplay();

    }

}//end of MainWindow::processFinishedPiece
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::prepareForNextPiece
//
// Prepare to process a new piece.
//

public void prepareForNextPiece()
{

//if so configured, reset all traces to begin at the left edge of the chart,
// otherwise new piece will be appended to right end of traces and the chart
// will scroll to display new data

if (globals.restartNewPieceAtLeftEdge) resetChartGroups();

//mark the starting point of a new piece in the data buffers
markSegmentStart();

}//end of MainWindow::prepareForNextPiece
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::handlePieceTransition
//
// Saves the data for the piece just processed and prepares to process a new
// piece.
//

public void handlePieceTransition()
{

//save the piece just finished
processFinishedPiece();

//prepare buffers for next piece
prepareForNextPiece();

//prepare hardware interface for new piece
hardware.setMode(Hardware.INSPECT);

}//end of MainWindow::handlePieceTransition
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Viewer::updatePrevMinWallDisplay
//
// Finds the minimum value for the Min Wall trace and updates the display.
//
// The chart group containing the trace is returned via hardware.hdwVs.
// The chart containing the trace is returned via hardware.hdwVs.
// The trace is returned via hardware.hdwVs.
//

public String updatePrevMinWallDisplay()
{

    String result = "", wallText;
    hardware.hdwVs.chartGroup = null;
    hardware.hdwVs.chart = null;
    hardware.hdwVs.trace = null;

    //check all chart groups for a Wall Max trace -- if there are more than one,
    //the value from the first one found will be used

    result = "";

    for (int i = 0; i < numberOfChartGroups; i++){
        wallText = chartGroups[i].getWallMinOrMaxText(true, hardware.hdwVs);
        if (!wallText.isEmpty()){
            hardware.hdwVs.chartGroup = chartGroups[i];
            result = result + wallText;
            break;
        }
    }//for (int i = 0; i < numberOfChartGroups; i++)

    if(hardware.hdwVs.chart != null)
        hardware.hdwVs.chart.updatePreviousMinWallValue(hardware.hdwVs.minWall);

    return(result);

}//end of MainWindow::updatePrevMinWallDisplay
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::isConfigGoodA
//
// This function checks for various configuration errors and returns true if
// it is okay to save/load to the data folders.
//
// If there is an error, an error message will be displayed and the function
// will return false.
//

public boolean isConfigGoodA()
{

//verify the data folder paths
if (!isConfigGoodB()) return(false);

//verify the job name
if (currentJobName.equals("")){
    displayErrorMessage("No job is selected."
            + " Use File/New Job or File/Change Job to correct this error.");
    return(false);
    }

return(true);  //no configuration error

}//end of MainWindow::isConfigGoodA
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::isConfigGoodB
//
// This function checks for if the data folder paths are good and returns true
// if it is okay to save/load to the data folders.
//
// If there is an error, an error message will be displayed and the function
// will return false.  The error message does not specify which path is bad
// because both are often set empty when either is bad.
//

public boolean isConfigGoodB()
{

if (primaryDataPath.equals("")){
    displayErrorMessage("The root Primary or Backup Data Path is invalid."
            + " Use Help/Setup System to repair this error.");
    return(false);
    }

if (backupDataPath.equals("")){
    displayErrorMessage("The root Primary or Backup Data Path is invalid."
            + " Use Help/Setup System to repair this error.");
    return(false);
    }

return(true);  //no configuration error

}//end of MainWindow::isConfigGoodB
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::createNewJob
//
// Allows the user to create a new job.
//

public void createNewJob()
{

//NOTE: save must be done BEFORE calling the dialog window else new changes
//may be overwritten or written to the wrong directory as the dialog window
//may save files or switch directories

saveEverything(); //save all data

NewJob newJob = new NewJob(mainFrame, primaryDataPath, backupDataPath, xfer,
                                                         globals.jobFileFormat);
newJob.init();

//if the NewJob window set rBoolean1 true, switch to the new job
if (xfer.rBoolean1){

    currentJobName = xfer.rString1; //use the new job name
    saveMainSettings(); //save the new current job name so it will be loaded

    //update the data paths
    currentJobPrimaryPath = primaryDataPath + currentJobName + "/";
    currentJobBackupPath = backupDataPath + currentJobName + "/";

    //save a copy of the job info to the new work order
    jobInfo.prepareForNewJob(currentJobPrimaryPath,
                                currentJobBackupPath, currentJobName);

    //exit the program, passing true to instantiate a new program which will
    //load the new job on startup - it is required to create a new
    //program and kill the old one so that all of the configuration data for
    //the job will be loaded properly

    exitProgram(false, true);

    }

}//end of MainWindow::createNewJob
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::changeJob
//
// Allows the user to switch to a different job.
//

public void changeJob()
{

//NOTE: save must be done BEFORE calling the dialog window else new changes
//may be overwritten or written to the wrong directory as the dialog window
//may save files or switch directories

saveEverything(); //save all data

ChooseJob chooseJob =
                new ChooseJob(mainFrame, primaryDataPath, backupDataPath, xfer);

 //does the actual choose job work -- info passed back via xfer object
chooseJob.init();

//if the ChooseJob window set rBoolean1 true, switch to the new job
if (xfer.rBoolean1){

    currentJobName = xfer.rString1; //use the new job name
    saveMainSettings(); //save the new current job name so it will be loaded

    //exit the program, passing true to instantiate a new program which will
    //load the new work order on startup - it is required to create a new
    //program and kill the old one so that all of the configuration data for
    //the job will be loaded properly

    exitProgram(false, true);

    }

}//end of MainWindow::changeJob
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::copyPreset
//
// Allows the user to copy a preset from a different job.
//
// The selected preset will be copied from the selected job folder to the
// current job folder.  The program will then be restarted to load the settings.
//

public void copyPreset()
{

//NOTE: save must be done BEFORE calling the dialog window else new changes
//may be overwritten or written to the wrong directory as the dialog window
//may save files or switch directories

saveEverything(); //save all data

CopyPreset copyPreset = new CopyPreset(
            mainFrame, primaryDataPath, backupDataPath, xfer, currentJobName);

copyPreset.init(); //initialize and to the actual work

//if the ChooseJob window set rBoolean1 true, switch to the new preset
if (xfer.rBoolean1){

    //no need to save main settings - the selected preset will have been
    //copied to the job folder so it will be loaded on restart

    //exit the program, passing true to instantiate a new program which will
    //load the new work order on startup - it is required to create a new
    //program and kill the old one so that all of the configuration data for
    //the job will be loaded properly

    exitProgram(false, true);

    }

}//end of MainWindow::copyPreset
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::changePreset
//
// Allows the user to switch to a different preset.
//
// The selected preset will be copied from the presets folder to the job
// folder.  The program will then be restarted to load the settings.
//

public void changePreset()
{

//NOTE: save must be done BEFORE calling the dialog window else new changes
//may be overwritten or written to the wrong directory as the dialog window
//may save files or switch directories

saveEverything(); //save all data

LoadPreset loadPreset = new LoadPreset(
            mainFrame, primaryDataPath, backupDataPath, xfer, currentJobName);

loadPreset.init(); //initialize and to the actual work

//if the ChooseJob window set rBoolean1 true, switch to the new preset
if (xfer.rBoolean1){

    //no need to save main settings - the selected preset will have been
    //copied to the job folder so it will be loaded on restart

    //exit the program, passing true to instantiate a new program which will
    //load the new work order on startup - it is required to create a new
    //program and kill the old one so that all of the configuration data for
    //the job will be loaded properly

    exitProgram(false, true);

    }

}//end of MainWindow::changePreset
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::logStatus
//
// Writes various status messages to the log window.
//

public void logStatus()
{

hardware.logStatus(logWindow.textArea);

}//end of MainWindow::logStatus
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::setupSystem
//
// Prepares the system for use by creating necessary folders and any other
// initialization required when the software is copied to a new computer.
//
// If the data directories are already present, the settings in Main Static
// Settings.ini will be changed to point to the directories.
//

public void setupSystem()
{

int n = JOptionPane.showConfirmDialog( mainFrame,
    "This feature should only be used by a technician -"
      + " do you want to continue?",
    "Warning", JOptionPane.YES_NO_OPTION);

if (n != JOptionPane.YES_OPTION) return; //bail out if user does not click yes

//create and display a file chooser
final JFileChooser fc = new JFileChooser();
fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
int returnVal = fc.showOpenDialog(mainFrame);

if (returnVal != JFileChooser.APPROVE_OPTION){
    displayWarningMessage("Setup cancelled - nothing done.");
    return;
    }

//selected file will actually be the selected directory because mode is
//JFileChooser.DIRECTORIES_ONLY
String targetDir = fc.getSelectedFile().toString();

//Users often get confused and try to create the data folders when they already
//exist - they often click on one of the existing folders in the browser
//window which would cause a new set of folders to be installed in the
//existing folder, which makes things confusing.  To avoid this, check to see
//if one of the folder names is part of the selected folder and truncate the
//selected folder so that the parent folder is used instead.

int p = -1;

if ((p = targetDir.indexOf(globals.primaryFolderName)) != -1){
    //chop off all after the offending directory
    targetDir = targetDir.substring(0, p);
    }

if ((p = targetDir.indexOf(globals.backupFolderName)) != -1){
    //chop off all after the offending directory
    targetDir = targetDir.substring(0, p);
    }

//add a separator if not one already at the end
if (!targetDir.endsWith(File.separator)) targetDir += File.separator;

//create the primary data directory
//note the extra space before "Primary" in the path name - this forces the
//primary to be listed first alphabetically when viewed in a file navigator
File primaryDir = new File (targetDir + globals.primaryFolderName);
if (!primaryDir.exists() && !primaryDir.mkdirs()){
    displayErrorMessage("Could not create the primary data directory -"
            + " no directories created.");
    return;
    }

//create the backup data directory
File backupDir = new File (targetDir + globals.backupFolderName);
if (!backupDir.exists() && !backupDir.mkdirs()){
    displayErrorMessage("Could not create the backup data directory -"
            + " only the primary directory was created.");
    return;
    }

//only save the new paths to the Main Static Settings.ini file if both folders
//were successfully created or already existed
//toString will return paths with / or \ separators depending on the system the
//software is installed on - apply a separator the to end as well
primaryDataPath = primaryDir.toString() + File.separator;
backupDataPath = backupDir.toString() + File.separator;

saveMainStaticSettings();

}//end of MainWindow::setupSystem
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::displayCalWindow
//
// Prepares and displays the calibration window.
//

public void displayCalWindow(String pActionCommand)
{

// the index number of the chart group and the chart which initiated the cal
// window display is appended to the action command - parse them to integers

int invokingChartGroupIndex =
   Integer.valueOf( pActionCommand.substring(pActionCommand.indexOf('~')+1,
                                              pActionCommand.lastIndexOf('~')));

int invokingChartIndex =
   Integer.valueOf(pActionCommand.substring(pActionCommand.lastIndexOf('~')+1));

//clear out the list of channels assigned to the chart
for (int i = 0; i < numberOfChannels; i++) calChannels[i] = null;

//For UT, clicking either trace labeled ID or OD brings up all channels
//for the chart regardless of trace - this is because ID/OD is tied to all
//traces.  In the future, perhaps add switch for other types of systems so
//that clicking on one trace only brings up the channels tied to that trace.

//used to calculate number of channels tied to the invoking chart
int i = 0, numberOfChartChannels = 0;

//scan through all channels and their gates, processing data from any that
//match the current graph and trace number - see note above for future mods
//to match the trace number also for non-UT systems

int numberOfGates;

for (int ch = 0; ch < numberOfChannels; ch++){

    //each channel gets a assigned a screen control by the UTCalibrator
    //object -- clear any previous settings out
    hardware.getChannels()[ch].calRadioButton = null;

    //get the number of gates for the currently selected channel
    numberOfGates = hardware.getNumberOfGates(ch);

    for (int g = 0; g < numberOfGates; g++){

        //store a reference to each channel with a gate which is tied to the
        //invoking chart group and chart and count the number of matches
        //multiple gates for a single channel may be tied to the same trace,
        //so break to the next channel when the first gate matches so the
        //channel is not added more than once

        if (hardware.getGate(ch, g).chartGroup == invokingChartGroupIndex &&
                    hardware.getGate(ch, g).chart == invokingChartIndex){
            calChannels[i++] = hardware.getChannels()[ch];
            break;
            }
        }//for (int g = 0;...
    }//for (int ch = 0;...

numberOfChartChannels = i; //this is the number of matching channels found

calWindow.setChannels(numberOfChartChannels, calChannels,
        chartGroups[invokingChartGroupIndex].getStripChart(invokingChartIndex),
        numberOfChannels, hardware.getChannels());

calWindow.setVisible(true);

}//end of MainWindow::displayCalWindow
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::processMainTimerEvent
//
// Handles any duties for the timer such as scanning the transducer and
// plotting the results.
//

public void processMainTimerEvent()
{

if (globals.beginExitProgram){
    //shut down hardware, clean up, save data
    //will also set beginExitProgram false and exitProgram true so this
    //will only get called once
    prepareToExitProgram(globals.saveOnExit);
    return;
    }

//After the beginExitProgram has been called, exitProgram will be true.  Monitor
//the pointer fileSaver - if it is not null then data is still being saved.
//When it goes null, saving is finished and the program can be shut down.
//Must stop the timer or it will call again during the destruction of objects
//it accesses.

if (globals.exitProgram) {

    if (fileSaver != null) return; //wait until saving is done

    //stop calling this timer during shutdown
    mainTimer.stop();

    //disposing of the frame will exit the program
    mainFrame.setVisible(false);
    mainFrame.dispose();

    //to get the program to cleanly exit while debugging in the IDE, must
    //use System.exit(0) - this may cause an exception if the program is
    //used as an Applet, so may want to test if program is an Applet and
    //skip this step in that case

    MainWindow mainWindow;

    //if a restart was requested, make a new main frame and start over
    if (globals.restartProgram)
        mainWindow = new MainWindow();
    else
        System.exit(0);

    }

//if the hardware interface has received an end of piece signal, save the
//finished piece and prepare for the next one
if (hardware.prepareForNewPiece){
    hardware.prepareForNewPiece = false;
    handlePieceTransition();
    }

//plot data on the graphs - if no data is being collected by the hardware
//because it is not in scan or inspect mode, then nothing will be plotted
doScan();

//allow the Capulin1 interface to handle necessary tasks
hardware.doTasks();

//if in monitor mode, retrieve I/O status info from Capulin1
if (monitorWindow.isVisible()) {
        monitorMode = true;
        byte[] monitorBuffer = hardware.getMonitorPacket(true);
        monitorWindow.updateStatus(monitorBuffer);
}
else
    if (monitorMode){ //if in monitor mode and window closes, exit the mode
        monitorMode = false;
        hardware.stopMonitor();
}


//if the cal window is opened, allow it to update it's display with the latest
//A-Scan from the currently selected channel
if (calWindow.isVisible()){
    //the channel index in the UTCalibrator object only relates to the list of
    //channels currently being handled by the UTCalibrator - use the channel's
    //actual channelIndex number stored in the channel object itself for
    //retrieving data

    if (calWindow.channels[calWindow.currentChannelIndex] != null){

        aScan = hardware.getAScan(
            calWindow.channels[calWindow.currentChannelIndex].channelIndex);

        if (aScan != null)
            calWindow.displayData(aScan.range, aScan.interfaceCrossingPosition,
                                                                aScan.buffer);
        }

    }// if (calWindow.isVisible())


    //hide the flag report dialog if need be
    if (printFlagReportDialog != null
            && closePrintFlagReportDialogTimer-- == 0){

        printFlagReportDialog.closeAndDispose();
        printFlagReportDialog = null;

    }

}//end of MainWindow::processMainTimerEvent
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::doScan
//
// Handles update of displays.
//

public void doScan()
{

for (int i = 0; i < numberOfChartGroups; i++) chartGroups[i].plotData();

}//end of MainWindow::doScan
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::stateChanged
//
// Responds to value changes in spinners, etc.
//
// You can tell which item was changed by using similar to:
//
// Object source = e.getSource();
//
// For simplicities sake, the following just updates all controls any time any
// one control is changed.
//

@Override
public void stateChanged(ChangeEvent e)
{

//copy values and states of all display controls to the Global variable set
updateAllSettings();

}//end of MainWindow::stateChanged
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::insertUpdate
//
// Responds to value changes in text areas and fields, specifically when a
// character is inserted. NOTE: This will get called after EVERY character
// inserted - updateAllSettings will get called every time but this shouldn't
// be a problem.
//

@Override
public void insertUpdate(DocumentEvent ev)
{

//copy values and states of all display controls to the Global variable set
updateAllSettings();

}//end of MainWindow::insertUpdate
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::removeUpdate
//
// Responds to value changes in text areas and fields, specifically when a
// character is removed. NOTE: This will get called after EVERY character
// removed - updateAllSettings will get called every time but this shouldn't
// be a problem.
//

@Override
public void removeUpdate(DocumentEvent ev)
{

//copy values and states of all display controls to the Global variable set
updateAllSettings();

}//end of MainWindow::removeUpdate
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::changedUpdate
//
// Responds to value changes in text areas and fields, specifically when the
// style of the text is changed.
//

@Override
public void changedUpdate(DocumentEvent ev)
{

//copy values and states of all display controls to the Global variable set
updateAllSettings();

}//end of MainWindow::changedUpdate
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::updateAllSettings
//
// Copies the values and states of all display controls to the corresponding
// variables in the Globals object.
//
// This function should be called when ANY control is modified so that the new
// states and values will be copied to the variable set.
//

public void updateAllSettings()
{

//globals.scanXDistance = scanXDistance.getDoubleValue();
//globals.transducerInfo.serialNumber = transducerSN.getText();

//flag that settings have been modified
globals.setOptionsModifiedFlag(true);

}//end of MainWindow::updateAllSettings
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::changeLanguage
//
// Calls all objects to force them to load new translation text per the
// language passed via pLanguage.
//

@Override
public void changeLanguage(String pLanguage)
{

//update text directly controlled by this object
loadLanguage(pLanguage);

//force all other objects to update their text displays

mainMenu.loadLanguage(pLanguage);

//force all components to repaint to make sure the text is updated
mainFrame.getContentPane().repaint();

}//end of MainWindow::changeLanguage
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::loadLanguage
//
// Sets the text displayed by various controls according to the selected
// language.
//
// Sets class variable "language" to "pLanguage" so outside classes can call
// this function to both set the variable and load new translations.
//


private void loadLanguage(String pLanguage)
{

language = pLanguage;

IniFile ini = null;

//if the ini file cannot be opened and loaded, exit without action
try {ini = new IniFile(
        "language\\Main Window - Capulin UT.language", Globals.mainFileFormat);}
catch(IOException e){return;}

}//end of MainWindow::loadLanguage
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::prepareToExitProgram
//
// Saves files and cleans up in preparation for shut down.
//
// Destroys the main window component, exiting the program.
//
// If pRestart = true, a new main frame is created.  This must be
// done to switch between configurations and presets as everything must be
// rebuilt to match the settings in the config file.
//
// If pSave is true, all job info data files are saved.
//

public void prepareToExitProgram(boolean pSave)
{

//stop the timer from calling this program repeatedly until close
globals.beginExitProgram = false;
//signal timer to watch for time to exit
globals.exitProgram = true;

//turn off all hardware functions
hardware.shutDown();

//if flag is true, save all data
//the timer function should monitor conditions to make sure save is completed
//before exiting since the save is handled by a separate thread
if (pSave) saveEverything();

}//end of MainWindow::prepareToExitProgram
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::exitProgram
//
// Saves files, cleans up, shuts down hardware, exits the program by signalling
// the main timer function.
//
// If pRestart = true, a new main frame is created.  This must be
// done to switch between configurations and presets as everything must be
// rebuilt to match the settings in the config file.
//
// If pSave is true, all job info data files are saved.
//

public void exitProgram(boolean pSave, boolean pRestart)
{

//signal timer to begin shut down process
globals.beginExitProgram = true;
//signal timer to save data or not
globals.saveOnExit = pSave;
//signal timer to restart the program or not
globals.restartProgram = pRestart;

}//end of MainWindow::exitProgram
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::windowClosing
//
// Handles actions necessary when the main window (and the program) are closed
// by clicking on the "X" icon.
//
// The default close option for the main JFrame should have been set to
// DO_NOTHING_ON_CLOSE in the constructor because we want to save files
// and clean up before actually closing.  If the default option is left in
// place, EXIT_ON_CLOSE, then the program will exit after this WindowClosing
// function finishes - aborting any file saving or clean up in progress.
//
// To close the program, a flag is set to signal the main timer to start the
// shut down sequence in an orderly fashion.
//

@Override
public void windowClosing(WindowEvent e)
{

exitProgram(true, false);

}//end of MainWindow::windowClosing
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::finalize
//
// Handles actions necessary when the main window (and the program) are closed
// by clicking on the "X" icon or by dispatching a WINDOW_CLOSING event from
// code triggered by the "File/Exit" option.
//
// NOTE: This function doesn't seem to get called for a JFrame when it is
// disposed of - the Java VM probably ceases running before that happens.
//

// function not used -- comments left here as instructional --

//end of MainWindow::finalize
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::(various window listener functions)
//
// These functions are implemented per requirements of interface WindowListener
// but do nothing at the present time.  As code is added to each function, it
// should be moved from this section and formatted properly.
//

@Override
public void windowClosed(WindowEvent e){}
@Override
public void windowOpened(WindowEvent e){}
@Override
public void windowIconified(WindowEvent e){}
@Override
public void windowDeiconified(WindowEvent e){}
@Override
public void windowActivated(WindowEvent e){}
@Override
public void windowDeactivated(WindowEvent e){}

//end of MainWindow::(various window listener functions)
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::componentResized
//
// Handles actions necessary when the window is resized by the user.
//

@Override
public void componentResized(ComponentEvent e)
{

//pack the window back to its smallest size again, effectively preventing
//the resize attempt

mainFrame.pack();

}//end of MainWindow::componentResized
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::displayErrorMessage
//
// Displays an error dialog with message pMessage.
//

private void displayErrorMessage(String pMessage)
{

JOptionPane.showMessageDialog(mainFrame, pMessage,
                                            "Error", JOptionPane.ERROR_MESSAGE);

}//end of MainWindow::displayErrorMessage
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::displayInfoMessage
//
// Displays an information dialog with message pMessage.
//

private void displayInfoMessage(String pMessage)
{

JOptionPane.showMessageDialog(mainFrame, pMessage,
                                       "Info", JOptionPane.INFORMATION_MESSAGE);

}//end of MainWindow::displayInfoMessage
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::displayWarningMessage
//
// Displays a warning dialog with message pMessage.
//

private void displayWarningMessage(String pMessage)
{

JOptionPane.showMessageDialog(mainFrame, pMessage,
                                       "Warning", JOptionPane.WARNING_MESSAGE);

}//end of MainWindow::displayWarningMessage
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MainWindow::(various component listener functions)
//
// These functions are implemented per requirements of interface
// ComponentListener but do nothing at the present time.  As code is added to
// each function, it should be moved from this section and formatted properly.
//

@Override
public void componentHidden(ComponentEvent e){}
@Override
public void componentShown(ComponentEvent e){}
@Override
public void componentMoved(ComponentEvent e){}

//end of MainWindow::(various component listener functions)
//-----------------------------------------------------------------------------


}//end of class MainWindow
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// class Main
//

public class Main{

//-----------------------------------------------------------------------------
// Main::createAndShowGUI
//
// Create the GUI and show it. For thread safety, this method should be invoked
// from the event-dispatching thread.  This is usually done by using
// invokeLater to schedule this funtion to be called from inside the event-
// dispatching thread.  This is necessary because the main function is not
// operating in the event-dispatching thread.  See the main function for more
// info.
//

private static void createAndShowGUI()
{

//instantiate an object to create and handle the main window JFrame
MainWindow mainWindow = new MainWindow();

}//end of Main::createAndShowGUI
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Main::main
//

public static void main(String[] args)
{

//Schedule a job for the event-dispatching thread:
//creating and showing this application's GUI.

javax.swing.SwingUtilities.invokeLater(
        new Runnable() {
            @Override
            public void run() { createAndShowGUI(); } });

}//end of Main::main
//-----------------------------------------------------------------------------

}//end of class Main
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Useful debugging code

//debug mks - sets to a light green
//setBackground(new Color(153, 204, 0));
//end debug mks

//debug mks - sets to red
//setBackground(new Color(255, 0, 0));
//end debug mks

//displays message on bottom panel of IDE
//System.out.println("File not found");

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
